<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="mask-icon" href="/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Synchronization, Part 1: Mutex Locks</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">

  <!-- Asynchronously load the code style sheet because we want everything loaded as fast as possible
       Also tag with ?v=time to bust the cache of any browser so updates appear -->
  <link async rel="stylesheet" href="/css/code-style.css?v='2018-11-28 20:00:31 -0600'">

  <!-- Don't load async because this will make the page render faster, plus the file is small.
       Also do the same cache busting magic here -->
  <link rel="stylesheet" href="/css/main.css?v='2018-11-28 20:00:31 -0600'">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <!-- Navigation button as html so we don't have to resize images -->
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>


            <!-- Inline tux for speed -->
            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            
            <li>
                <a class="navbar-link" href="/assignments.html">Assignments</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/quiz_topics.html">Quizzes</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/search.html">Search</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/wikibook_project/Index.html">Wikibook Project</a>
            </li>
            
          </ul>
        </div>
        </div>
</nav>


<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Synchronization, Part 1: Mutex Locks

              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki/Synchronization,-Part-1:-Mutex-Locks">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
            
          </div></div></div>
        </div></div>
      </div>
      
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_what-is-a-critical-section" href="#what-is-a-critical-section" class="fancy-link">What is a Critical Section?</a></li>
<li><a id="toc_is-just-incrementing-a-variable-a-critical-section" href="#is-just-incrementing-a-variable-a-critical-section" class="fancy-link">Is just incrementing a variable a critical section?</a></li>
<li><a id="toc_how-do-i-ensure-only-one-thread-at-a-time-can-access-a-global-variable" href="#how-do-i-ensure-only-one-thread-at-a-time-can-access-a-global-variable" class="fancy-link">How do I ensure only one thread at a time can access a global variable?</a></li>
<li><a id="toc_if-i-lock-a-mutex-does-it-stop-all-other-threads" href="#if-i-lock-a-mutex-does-it-stop-all-other-threads" class="fancy-link">If I lock a mutex, does it stop all other threads?</a></li>
<li><a id="toc_are-there-other-ways-to-create-a-mutex" href="#are-there-other-ways-to-create-a-mutex" class="fancy-link">Are there other ways to create a mutex?</a></li>
<li><a id="toc_so-pthread_mutex_lock-stops-the-other-threads-when-they-read-the-same-variable" href="#so-pthread_mutex_lock-stops-the-other-threads-when-they-read-the-same-variable" class="fancy-link">So <code class="highlighter-rouge">pthread_mutex_lock</code> stops the other threads when they read the same variable?</a></li>
<li><a id="toc_can-i-create-mutex-before-fork-ing" href="#can-i-create-mutex-before-fork-ing" class="fancy-link">Can I create mutex before fork-ing?</a></li>
<li><a id="toc_if-one-thread-locks-a-mutex-can-another-thread-unlock-it" href="#if-one-thread-locks-a-mutex-can-another-thread-unlock-it" class="fancy-link">If one thread locks a mutex can another thread unlock it?</a></li>
<li><a id="toc_can-i-use-two-or-more-mutex-locks" href="#can-i-use-two-or-more-mutex-locks" class="fancy-link">Can I use two or more mutex locks?</a></li>
<li><a id="toc_is-there-any-overhead-in-calling-lock-and-unlock" href="#is-there-any-overhead-in-calling-lock-and-unlock" class="fancy-link">Is there any overhead in calling lock and unlock?</a></li>
<li><a id="toc_simplest-complete-example" href="#simplest-complete-example" class="fancy-link">Simplest complete example?</a></li>
<li><a id="toc_what-happens-if-i-forget-to-unlock" href="#what-happens-if-i-forget-to-unlock" class="fancy-link">What happens if I forget to unlock?</a></li>
<li><a id="toc_when-can-i-destroy-the-mutex" href="#when-can-i-destroy-the-mutex" class="fancy-link">When can I destroy the mutex?</a></li>
<li><a id="toc_can-i-copy-a-pthread_mutex_t-to-a-new-memory-locaton" href="#can-i-copy-a-pthread_mutex_t-to-a-new-memory-locaton" class="fancy-link">Can I copy a pthread_mutex_t to a new memory locaton?</a></li>
<li><a id="toc_what-would-a-simple-implementation-of-a-mutex-look-like" href="#what-would-a-simple-implementation-of-a-mutex-look-like" class="fancy-link">What would a simple implementation of a mutex look like?</a></li>
<li><a id="toc_how-do-i-find-out-more" href="#how-do-i-find-out-more" class="fancy-link">How do I find out more?</a></li>
</ul>
</div>
      
      <div id="content">
          <div class="wrapper">

</div>
          <div class="wrapper">

<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-a-critical-section" class="title-text">What is a Critical Section?<a class="anchor title-text" href="#what-is-a-critical-section">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>A critical section is a section of code that can only be executed by one thread at a time, if the program is to function correctly. If two threads (or processes) were to execute code inside the critical section at the same time then it is possible that program may no longer have correct behavior.</p></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="is-just-incrementing-a-variable-a-critical-section" class="title-text">Is just incrementing a variable a critical section?<a class="anchor title-text" href="#is-just-incrementing-a-variable-a-critical-section">#</a>
</h2></div>




<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Possibly. Incrementing a variable (<code class="highlighter-rouge">i++</code>) is performed in three individual steps: Copy the memory contents to the CPU register. Increment the value in the CPU. Store the new value in memory. If the memory location is only accessible by one thread (e.g. automatic variable <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/i" class="fancy-link">i</a></code> below) then there is no possibility of a race condition and no Critical Section associated with <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/i" class="fancy-link">i</a></code>. However the <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/sum" class="fancy-link">sum</a></code> variable is a global variable and accessed by two threads. It is possible that two threads may attempt to increment the variable at the same time.</p>
<pre><code class="language-C"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
</span>
</code></pre>
<p>Typical output of the above code is <code class="highlighter-rouge">ARGGGH sum is 8140268</code>
A different sum is printed each time the program is run because there is a race condition; the code does not stop two threads from reading-writing <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/sum" class="fancy-link">sum</a></code> at the same time. For example both threads copy the current value of sum into CPU that runs each thread (let’s pick 123). Both threads increment one to their own copy. Both threads write back the value (124). If the threads had accessed the sum at different times then the count would have been 125.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-do-i-ensure-only-one-thread-at-a-time-can-access-a-global-variable" class="title-text">How do I ensure only one thread at a time can access a global variable?<a class="anchor title-text" href="#how-do-i-ensure-only-one-thread-at-a-time-can-access-a-global-variable">#</a>
</h2></div>






<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>You mean, “Help - I need a mutex!”
If one thread is currently inside a critical section we would like another thread to wait until the first thread is complete. For this purpose we can use a mutex (short for Mutual Exclusion).</p>
<p>For simple examples the smallest amount of code we need to add is just three lines:</p>
<pre><code class="language-C"><span class="n">pthread_mutex_t</span>
</code></pre>
<p>Once we are finished with the mutex we should also call <code class="highlighter-rouge">pthread_mutex_destroy(&amp;m)</code> too. Note, you can only destroy an unlocked mutex. Calling destroy on a destroyed lock, initializing an initialized lock, locking an already locked lock, unlocking an unlocked lock etc are unsupported (at least for default mutexes) and usually result in undefined behavior.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="if-i-lock-a-mutex-does-it-stop-all-other-threads" class="title-text">If I lock a mutex, does it stop all other threads?<a class="anchor title-text" href="#if-i-lock-a-mutex-does-it-stop-all-other-threads">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>No, the other threads will continue. It’s only when a thread attempts to lock a mutex that is already locked, will the thread have to wait. As soon as the original thread unlocks the mutex, the second (waiting) thread will acquire the lock and be able to continue.</p></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="are-there-other-ways-to-create-a-mutex" class="title-text">Are there other ways to create a mutex?<a class="anchor title-text" href="#are-there-other-ways-to-create-a-mutex">#</a>
</h2></div>








<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Yes. You can use the macro <code class="highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> only for global (‘static’) variables.
<code class="highlighter-rouge">m = PTHREAD_MUTEX_INITIALIZER</code> is equivalent to the more general purpose
<code class="highlighter-rouge">pthread_mutex_init(&amp;m,NULL)</code>. The init version includes options to trade performance for additional error-checking and advanced sharing options.</p>
<pre><code class="language-C"><span class="n">pthread_mutex_t</span>
</code></pre>
<p>Things to keep in mind about <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/init" class="fancy-link">init</a></code> and <code class="highlighter-rouge">destroy</code>:</p>
<ul>
  <li>Multiple threads init/destroy has undefined behavior</li>
  <li>Destroying a locked mutex has undefined behavior</li>
  <li>Basically try to keep to the pattern of one thread initializing a mutex and one and only one thread initializing a mutex.</li>
</ul>
</div></div></div>
</div></div>

<div class="pad"><div class="card">
<div class="title"><h2 id="so-pthread_mutex_lock-stops-the-other-threads-when-they-read-the-same-variable" class="title-text">So <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> stops the other threads when they read the same variable?<a class="anchor title-text" href="#so-pthread_mutex_lock-stops-the-other-threads-when-they-read-the-same-variable">#</a>
</h2></div>







<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>No. A mutex is not that smart - it works with code (threads), not data. Only when another thread calls <code class="highlighter-rouge"><a href="https://linux.die.net/man/2/lock" class="fancy-link">lock</a></code> on a locked mutex will the second thread need to wait until the mutex is unlocked.</p>
<p>Consider</p>
<pre><code class="language-C"><span class="kt">int</span>
</code></pre>
<p>Will still cause a race condition.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="can-i-create-mutex-before-fork-ing" class="title-text">Can I create mutex before fork-ing?<a class="anchor title-text" href="#can-i-create-mutex-before-fork-ing">#</a>
</h2></div>




<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Yes - however the child and parent process will not share virtual memory and each one will have a mutex independent of the other.</p>
<p>(Advanced note: There are advanced options using shared memory that allow a child and parent to share a mutex if it’s created with the correct options and uses a shared memory segment. See <a href="http://stackoverflow.com/questions/19172541/procs-fork-and-mutexes" class="fancy-link wiki-link">stackoverflow example</a>)</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="if-one-thread-locks-a-mutex-can-another-thread-unlock-it" class="title-text">If one thread locks a mutex can another thread unlock it?<a class="anchor title-text" href="#if-one-thread-locks-a-mutex-can-another-thread-unlock-it">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>No. The same thread must unlock it.</p></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="can-i-use-two-or-more-mutex-locks" class="title-text">Can I use two or more mutex locks?<a class="anchor title-text" href="#can-i-use-two-or-more-mutex-locks">#</a>
</h2></div>






<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Yes! In fact it’s common to have one lock per data structure that you need to update.</p>
<p>If you only have one lock, then they may be significant contention for the lock between two threads that was unnecessary. For example if two threads were updating two different counters, it might not be necessary to use the same lock.</p>
<p>However simply creating many locks is insufficient: It’s important to be able to reason about critical sections e.g. it’s important that one thread can’t read two data structures while they are being updated and temporarily in an inconsistent state.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="is-there-any-overhead-in-calling-lock-and-unlock" class="title-text">Is there any overhead in calling lock and unlock?<a class="anchor title-text" href="#is-there-any-overhead-in-calling-lock-and-unlock">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>There is a small amount of overhead of calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link">pthread_mutex_lock</a></code> and <code class="highlighter-rouge">_unlock</code>; however this is the price you pay for correctly functioning programs!</p></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="simplest-complete-example" class="title-text">Simplest complete example?<a class="anchor title-text" href="#simplest-complete-example">#</a>
</h2></div>








<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>A complete example is shown below</p>
<pre><code class="language-C"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
</span>
</code></pre>
<p>In the code above, the thread gets the lock to the counting house before entering. The critical section is only the <code class="highlighter-rouge">sum += 1</code> so the following version is also correct but slower -</p>
<pre><code class="language-C"><span class="k">for</span>
</code></pre>
<p>This process runs slower because we lock and unlock the mutex a million times, which is expensive - at least compared with incrementing a variable. (And in this simple example we didn’t really need threads - we could have added up twice!)  A faster multi-thread example would be to add one million using an automatic(local) variable and only then adding it to a shared total after the calculation loop has finished:</p>
<pre><code class="language-C"><span class="kt">int</span>
</code></pre>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-happens-if-i-forget-to-unlock" class="title-text">What happens if I forget to unlock?<a class="anchor title-text" href="#what-happens-if-i-forget-to-unlock">#</a>
</h2></div>





<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Deadlock! We will talk about deadlock a little bit later but what is the problem with this loop if called by multiple threads.</p>
<pre><code class="language-C"><span class="k">while</span>
</code></pre>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="when-can-i-destroy-the-mutex" class="title-text">When can I destroy the mutex?<a class="anchor title-text" href="#when-can-i-destroy-the-mutex">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>You can only destroy an unlocked mutex.</p></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="can-i-copy-a-pthread_mutex_t-to-a-new-memory-locaton" class="title-text">Can I copy a pthread_mutex_t to a new memory locaton?<a class="anchor title-text" href="#can-i-copy-a-pthread_mutex_t-to-a-new-memory-locaton">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>No, copying the bytes of the mutex to a new memory location and then using the copy is <em>not</em> supported.</p></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-would-a-simple-implementation-of-a-mutex-look-like" class="title-text">What would a simple implementation of a mutex look like?<a class="anchor title-text" href="#what-would-a-simple-implementation-of-a-mutex-look-like">#</a>
</h2></div>









<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>A simple (but incorrect!) suggestion is shown below. The <code class="highlighter-rouge">unlock</code> function simply unlocks the mutex and returns. The lock function first checks to see if the lock is already locked. If it is currently locked, it will keep checking again until another thread has unlocked the mutex.</p>
<pre><code class="language-C"><span class="c1">// Version 1 (Incorrect!)</span>
</code></pre>
<p>Version 1 uses ‘busy-waiting’ (unnecessarily wasting CPU resources) however there is a more serious problem: We have a race-condition!</p>
<p>If two threads both called <code class="highlighter-rouge"><a href="https://linux.die.net/man/2/lock" class="fancy-link">lock</a></code> concurrently it is possible that both threads would read ‘m_locked’ as zero. Thus both threads would believe they have exclusive access to the lock and both threads will continue. Ooops!</p>
<p>We might attempt to reduce the CPU overhead a little by calling <code class="highlighter-rouge">pthread_yield()</code> inside the loop  - pthread_yield suggests to the operating system that the thread does not use the CPU for a short while, so the CPU may be assigned to threads that are waiting to run. But does not fix the race-condition. We need a better implementation - can you work how to prevent the race-condition?</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-do-i-find-out-more" class="title-text">How do I find out more?<a class="anchor title-text" href="#how-do-i-find-out-more">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p><a href="http://cs-education.github.io/sys" class="fancy-link wiki-link">Play!</a> Read the man page!</p>
<ul>
  <li><a href="http://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link wiki-link">pthread_mutex_lock man page</a></li>
  <li><a href="http://linux.die.net/man/3/pthread_mutex_unlock" class="fancy-link wiki-link">pthread_mutex_unlock man page</a></li>
  <li><a href="http://linux.die.net/man/3/pthread_mutex_init" class="fancy-link wiki-link">pthread_mutex_init man page</a></li>
  <li><a href="http://linux.die.net/man/3/pthread_mutex_destroy" class="fancy-link wiki-link">pthread_mutex_destroy man page</a></li>
</ul>
</div></div></div>
</div></div>
</div>
          
          <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/synchronization-part-1-mutex-locks.md";
  </script>
  <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Again bust cache on the main.js file -->
<script src="/js/main.js?v='2018-11-28 20:00:31 -0600'"></script>

<script>
<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
