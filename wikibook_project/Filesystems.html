<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="mask-icon" href="/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Filesystems</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">

  <!-- Asynchronously load the code style sheet because we want everything loaded as fast as possible
       Also tag with ?v=time to bust the cache of any browser so updates appear -->
  <link async rel="stylesheet" href="/css/code-style.css?v='2018-11-28 20:00:31 -0600'">

  <!-- Don't load async because this will make the page render faster, plus the file is small.
       Also do the same cache busting magic here -->
  <link rel="stylesheet" href="/css/main.css?v='2018-11-28 20:00:31 -0600'">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <!-- Navigation button as html so we don't have to resize images -->
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>


            <!-- Inline tux for speed -->
            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            
            <li>
                <a class="navbar-link" href="/assignments.html">Assignments</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/quiz_topics.html">Quizzes</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/search.html">Search</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
            
            <li>
                <a class="navbar-link" href="/wikibook_project/Index.html">Wikibook Project</a>
            </li>
            
          </ul>
        </div>
        </div>
</nav>


<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Filesystems

              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
            
          </div></div></div>
        </div></div>
      </div>
      
      <div id="content">
          <div class="wrapper">

</div>
          <div class="wrapper">
<ul>
  <li>
<a href="#filesystems" class="fancy-link wiki-link">Filesystems</a>
    <ul>
      <li>
<a href="#what-is-a-filesystem" class="fancy-link wiki-link">What is a filesystem?</a>
        <ul>
          <li><a href="#the-file-api" class="fancy-link wiki-link">The File API</a></li>
        </ul>
      </li>
      <li>
<a href="#storing-data-on-disk" class="fancy-link wiki-link">Storing data on disk</a>
        <ul>
          <li><a href="#file-contents" class="fancy-link wiki-link">File Contents</a></li>
          <li><a href="#directory-implementation" class="fancy-link wiki-link">Directory Implementation</a></li>
          <li><a href="#unix-directory-conventions" class="fancy-link wiki-link">Unix Directory Conventions</a></li>
          <li><a href="#how-do-i-list-the-contents-of-a-directory" class="fancy-link wiki-link">How do I list the contents of a directory?</a></li>
          <li><a href="#linking" class="fancy-link wiki-link">Linking</a></li>
          <li><a href="#pathing" class="fancy-link wiki-link">Pathing</a></li>
          <li><a href="#metadata" class="fancy-link wiki-link">Metadata</a></li>
        </ul>
      </li>
      <li>
<a href="#permissions-and-bits" class="fancy-link wiki-link">Permissions and bits</a>
        <ul>
          <li><a href="#user-idgroup-id" class="fancy-link wiki-link">User id/Group id</a></li>
          <li><a href="#readingchanging-file-permissions" class="fancy-link wiki-link">Reading/Changing file permissions</a></li>
          <li><a href="#understanding-the-umask" class="fancy-link wiki-link">Understanding the ‘umask’</a></li>
          <li><a href="#the-setuid-bit" class="fancy-link wiki-link">The ‘setuid’ bit</a></li>
          <li><a href="#the-sticky-bit" class="fancy-link wiki-link">The ‘sticky’ bit</a></li>
        </ul>
      </li>
      <li>
<a href="#virtual-filesystems-and-other-filesystems" class="fancy-link wiki-link">Virtual filesystems and other filesystems</a>
        <ul>
          <li><a href="#managing-files-and-filesystems" class="fancy-link wiki-link">Managing files and filesystems</a></li>
          <li><a href="#obtaining-random-data" class="fancy-link wiki-link">Obtaining random data</a></li>
          <li><a href="#copying-files" class="fancy-link wiki-link">Copying Files</a></li>
          <li><a href="#what-happens-when-i-touch-a-file" class="fancy-link wiki-link">Updating Modification Time</a></li>
          <li><a href="#managing-filesystems" class="fancy-link wiki-link">Managing Filesystems</a></li>
        </ul>
      </li>
      <li><a href="#memory-mapped-io" class="fancy-link wiki-link">Memory Mapped IO</a></li>
      <li>
<a href="#reliable-single-disk-filesystems" class="fancy-link wiki-link">Reliable Single Disk Filesystems</a>
        <ul>
          <li><a href="#redundancy" class="fancy-link wiki-link">RAID</a></li>
          <li><a href="#higher-level-raids" class="fancy-link wiki-link">Higher Level Raids</a></li>
        </ul>
      </li>
      <li>
<a href="#simple-filesystem-model" class="fancy-link wiki-link">Simple Filesystem Model</a>
        <ul>
          <li><a href="#performing-reads" class="fancy-link wiki-link">Performing Reads</a></li>
          <li><a href="#performing-writes" class="fancy-link wiki-link">Performing Writes</a></li>
          <li><a href="#adding-deletes" class="fancy-link wiki-link">Adding Deletes</a></li>
        </ul>
      </li>
      <li><a href="#topics" class="fancy-link wiki-link">Topics</a></li>
      <li><a href="#questions" class="fancy-link wiki-link">Questions</a></li>
    </ul>
  </li>
</ul>

<p>[1][] <span> </span></p>



<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-a-filesystem" class="title-text">What is a filesystem?<a class="anchor title-text" href="#what-is-a-filesystem">#</a>
</h2></div>























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>You may have encountered the old unix adage, “everything is a file”. In most UNIX systems, files operations provide an interface to abstract many different operations. Network sockets, hardware devices and even data on disk are all represented by a file-like object. A file-like object must follow certain conventions:</p>
<ol>
  <li>
    <p>It must present it self to the filesystem</p>
  </li>
  <li>
    <p>It must support common filesystem operations, such as <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code></span>, <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code></span>, <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code></span></p>
  </li>
</ol>
<p>A filesystem is an implementation of the file interface. In this chapter, we will be exploring the various callbacks a filesystem provides and some typical functionality or implementation details associated with this. In this class, we will mostly talk about filesystems that serve to allow users to access data on disk. These filesystems are integral to modern computers. Filesystems not only deal with storing local files, they handle special devices that allow for safe communication between the kernel and user space. Filesystems also deal with failures, scalability, indexing, encryption, compression and performance. Filesystems handle the abstraction between a file which contains data and how exactly that data is stored on disk, partitioned, and protected.</p>
<p>Although filesystems are usually thought of as a kind of tree, most filesystems are usually a directed graph, a model we will explore in depth later in this chapter. Before we dive into the details of a filesystem, let’s take a look at some examples.</p>
<ol>
  <li>
    <p><span><code class="highlighter-rouge">ext4</code></span> Usually mounted at /, this is the filesystem that usually provides disk access as you’re used to.</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">procfs</code></span> Usually mounted at /proc, provides information and control over processes.</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/2/sysfs" class="fancy-link">sysfs</a></code></span> Usually mounted at /sys, a more mordern version of /proc that also allows control over various other hardware such as network sockets.</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">tmpfs</code></span> Mounted at /tmp in some systems, an in-memory filesystem to hold temporary files.</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/sshfs" class="fancy-link">sshfs</a></code></span> A filesystem that syncs files across the ssh protocol.</p>
  </li>
</ol>
<p>To clarify, a mount point is simply a mapping of a directory to a filesystem represented in the kernel. What this means is that to resolve which filesystem a structure a call must resolve to. Meaning that <span><code class="highlighter-rouge">/root</code></span> is resolved by the <span><code class="highlighter-rouge">ext4</code></span> filesystem in our case, but <span><code class="highlighter-rouge">/proc/2</code></span> is resolved by the <span><code class="highlighter-rouge">procfs</code></span> system even though it contains <span><code class="highlighter-rouge">/</code></span> as a subsystem.</p>
<p>As you may have noticed, some of these filesystems provide an interface to things that aren’t a “file” as you might colloquially refer to them. Filesystems such as <span><code class="highlighter-rouge">procfs</code></span> are usually refered to as <em>virtual</em> filesystems, since they don’t provide data access in the same sense as a traditional filesystem would. Technically, all filesystems in the kernel are represented by virtual filesystem, but in our class we will differentiate <em>virtual</em> filesystems as filesystems that actually don’t store anything on a hard disk.</p>
<h3 id="the-file-api" class="title-text">The File API</h3>
<p>A filesystem must provide callback functions to a variety of actions. Some of them as listed below:</p>
<ul>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code></span> Opens a file for IO</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code></span> Read contents of a file</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code></span> Write to a file</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/close" class="fancy-link">close</a></code></span> Close a file and free associated resources</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/chmod" class="fancy-link">chmod</a></code></span> Modify permissions of a file</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/ioctl" class="fancy-link">ioctl</a></code></span> Interact with device parameters of character devices such as terminals</p>
  </li>
</ul>
<p>Not every filesystem supports all the possible callback functions. For example many filesystems do not implement <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/ioctl" class="fancy-link">ioctl</a></code></span> or <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/link" class="fancy-link">link</a></code></span>. In this chapter, we will not be examining each filesystem callback. If you would like to learn more about this interface, try looking at the documentation for FUSE, the source code for glibc or the linux manpages.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="storing-data-on-disk" class="title-text">Storing data on disk<a class="anchor title-text" href="#storing-data-on-disk">#</a>
</h2></div>

















































































































































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>In order to understand how a filesystem interacts with data on disk, there are three key terms we will be using.</p>
<ol>
  <li>
    <p><span><code class="highlighter-rouge">disk block</code></span> A disk block is a portion of the disk that is reserved for storing the contents of a file or a directory.</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">inode</code></span> An inode <em>is</em> a file or directory. This means that an inode contains metadata about the file as well as pointers to disk blocks so that the file can actually be written to or read from.</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">superblock</code></span> A superblock contains metadata about the inodes and disk blocks. An example superblock can store how full each disk block is, which inodes are being used etc. Modern filesystems may actually contain multiple superblocks and a sort-of super-super block that keeps track of which sectors are governed by which superblocks. This tends to help with fragmentation.</p>
  </li>
</ol>
<p>These structures all are presented in the diagram below.</p>
<p><img src="https://raw.githubusercontent.com/illinois-cs241/wikibook-project/master/filesystems/images/disk.gif"></p>
<p>It may seem overwhelming, but by the end of this chapter, we will be able to make sense of every part of the filesystem.</p>
<p>In order to reason about data on some form of storage (spinning disks, solid state drives, magnetic tape, etc.), it is common practice to first consider the medium of storage as a collection of <em>blocks</em>. A block can be thought of as a continguous region on disk, and while it’s size is sometimes determined by some property of the underlying hardware, it is more frequently determined based off of the size of a page of memory for a given system, so that data from the disk can be cached in memory for faster access - a very important feature of many filesystems.</p>
<p>Usually, a filesystem has a special block denoted as a <em>superblock</em> which stores metadata about the filesystem such as a journal (which logs changes to the filesystem), a table of inodes and where the first inode is stored on disk, etc. The important thing about a superblock is that it is in a known location on disk.</p>
<p>The inode is the most important structure for our filesystem as it represents a file. Before we explore it in depth, let’s list out the key information we need to have a usable file:</p>
<ul>
  <li>
    <p>Name</p>
  </li>
  <li>
    <p>File size</p>
  </li>
  <li>
    <p>Time created, last modified, last accessed</p>
  </li>
  <li>
    <p>Permissions</p>
  </li>
  <li>
    <p>Filepath</p>
  </li>
  <li>
    <p>Checksum</p>
  </li>
  <li>
    <p>File data</p>
  </li>
</ul>
<h3 id="file-contents" class="title-text">File Contents</h3>
<p><img src="https://raw.githubusercontent.com/illinois-cs241/wikibook-project/master/filesystems/images/inode_with_signatures.jpg"></p>
<p>From <a href="http://en.wikipedia.org/wiki/Inode" class="fancy-link wiki-link">Wikipedia</a>:</p>
<blockquote>
  <p><em>In a Unix-style file system, an index node, informally referred to as an inode, is a data structure used to represent a filesystem object, which can be one of various things including a file or a directory. Each inode stores the attributes and disk block location(s) of the filesystem object’s data. Filesystem object attributes may include manipulation metadata (e.g. change, access, modify time), as well as owner and permission data (e.g. group-id, user-id, permissions).</em></p>
</blockquote>
<p>Typically, the superblock stores an array of inodes, each of which stores direct, and potentially several kinds of indirect pointers to disk blocks. Since inodes are stored in the superblock, most filesystems have a limit on how many inodes can exist. Since each inode corresponds to a file, this is also a limit on how many files that filesystem can have. Trying to overcome this problem by storing inodes in some other location greatly increases the complexity of the filesystem. Trying to reallocate space for the inode table is also infeasible since every byte following the end of the inode array would have to be shifted, a highly expensive operation. This isn’t to say there aren’t any solutions at all, although typically there is no need to increase the number of inodes since the number of inodes is usually sufficiently high.</p>
<p>Big idea: Forget names of files: The ‘inode’ is the file.</p>
<p>It is common to think of the file name as the ‘actual’ file. It’s not! Instead consider the inode as the file. The inode holds the meta-information (last accessed, ownership, size) and points to the disk blocks used to hold the file contents. However, the inode does not usually store a filename. Filenames are usually only stored in directories. (see below)</p>
<p>For example, to read the first few bytes of the file, follow the first direct block pointer to the first direct block and read the first few bytes. Writing follows the same process. If you want to read the entire file, keep reading direct blocks until you’ve read a number of bytes equal to the size of the file. If the total size of the file is less than that of the number of direct blocks multiplied by the size of a block, then unsued block pointers will be undefined. Similarly, if the size of a file is not a multiple of the size of a block, data past the end of the last byte in the last block will be garbage.</p>
<p>What if a file is bigger than the maximum space addressable by it’s direct blocks?</p>
<blockquote>
  <p>“All problems in computer science can be solved by another level of indirection.” - David Wheeler</p>
</blockquote>
<p>Except the problem of too many layers of indirection.</p>
<p>To solve this problem, we introduce the indirect blocks. An indirect block is a block that store pointers to more data blocks. Similarly a double indirect block stores pointers to indirect blocks and the concept can be generalized to arbitrary levels of indirection. This is a very important concept, since as inodes are stored in the superblock, or some other strucutre in a well known location with a constant amount of space, indirection allows exponential increases in the amount of space an inode can keep track of.</p>
<p>As a worked example, suppose we divide the disk into 4KB blocks and we want to address up to 2^32 blocks. The maximum disk size is 4KB *2^32 = 16TB (remember 2^10 = 1024). A disk block can store 4KB / 4B (each pointer needs to be 32 bits) = 1024 pointers. Each pointer refers to a 4KB disk block - so you can refer up to 1024*4KB = 4MB of data. For the same disk configuration, a double indirect block stores 1024 pointers to 1024 indirection tables. Thus a double-indirect block can refer up to 1024 * 4MB = 4GB of data. Similarly, a triple indirect block can refer up to 4TB of data. Naturally though, this is three times as slow.</p>
<h3 id="directory-implementation" class="title-text">Directory Implementation</h3>
<p>A directory is just a mapping of names to inode numbers. It’s typically just a normal file, but with some special bits set in its inode and a very specific structure for its contents. POSIX provides a small set of functions to read the filename and inode number for each entry, which we will talk about in depth later in this chapter.</p>
<p>Let’s think about what it looks like in the actual file system. Theoretically, directories are just like actual files. The disk blocks will contain <em>directory entries</em> or <em>dirents</em>. What that means is that our disk block can look like this</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| inode_num | name   | | ----------- | ------ |
| 2043567   | hi.txt | | ... |
</code></pre></div></div>
<p>Each directory entry could either be a fixed size, or a variable c-string. It depends on how the particular filesystem implements it at the lower level. To see a mapping of filenames to inode numbers on a POSIX system, from a shell, use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/ls" class="fancy-link">ls</a></code></span> with the <span><code class="highlighter-rouge">-i</code></span> option</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ls -i
12983989 dirlist.c      12984068 sandwich.c
</code></pre></div></div>
<h3 id="unix-directory-conventions" class="title-text">Unix Directory Conventions</h3>
<p>In standard unix file systems the following entries are specially added on requests to read a directory.</p>
<ol>
  <li>
    <p><span><code class="highlighter-rouge">.</code></span> represents the current directory</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">..</code></span> represents the parent directory</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">~</code></span> is the name of the home directory usually</p>
  </li>
</ol>
<p>Note that <span><code class="highlighter-rouge">...</code></span> is NOT a valid representation of any directory (this not the grandparent directory). It <em>could</em> however be the name of a file on disk. Though confusingly, <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/zsh" class="fancy-link">zsh</a></code></span> provides this as a handy shortcut to the grandparent directory should it exist.</p>
<p>Additional facts about name-related conventions:</p>
<ol>
  <li>
    <p>Files that start with ’.’ on disk are conventionally considered ’hidden’ and will not be listed by programs like <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/ls" class="fancy-link">ls</a></code></span> without additional flags (<span><code class="highlighter-rouge">-a</code></span>). This is not a feature of the filesystem and programs may choose to ignore this.</p>
  </li>
  <li>
    <p>Some files may also start with a null byte. These are usually <em>abstract unix sockets</em> and are used to prevent cluttering up the filesystem since they will be effectively hidden by any program not expecting them. They will, however, be listed by tools that detail information about sockets, so this is not a feature providing security.</p>
  </li>
</ol>
<h3 id="how-do-i-list-the-contents-of-a-directory" class="title-text">How do I list the contents of a directory?</h3>
<p>While interacting with a file in C is done by using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code></span> to open the file and then <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code></span> or <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code></span> to interact with the file before calling <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/close" class="fancy-link">close</a></code></span> to release resources, directories have special calls such as, <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/opendir" class="fancy-link">opendir</a></code></span>, <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/closedir" class="fancy-link">closedir</a></code></span> and <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/readdir" class="fancy-link">readdir</a></code></span>. There is no function <span><code class="highlighter-rouge">writedir</code></span> since typically that implies creating a file or link.</p>
<p>To explore these functions, let’s write a program to search the contents of a directory for a particular file. (The code below has a bug, try to spot it!)</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>The above code has a subtle bug: It leaks resources! If a matching filename is found then ‘closedir’ is never called as part of the early return. Any file descriptors opened, and any memory allocated, by opendir are never released. This means eventually the process will run out of resources and an <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code></span> or <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/opendir" class="fancy-link">opendir</a></code></span> call will fail.</p>
<p>The fix is to ensure we free up resources in every possible code-path. In the above code this means calling <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/closedir" class="fancy-link">closedir</a></code></span> before <span><code class="highlighter-rouge">return 1</code></span>. Forgetting to release resources is a common C programming bug because there is no support in the C lanaguage to ensure resources are always released with all codepaths.</p>
<p>Note: after a call to fork(), either (XOR) the parent or the child can use readdir(), rewinddir() or seekdir(). If both the parent and the child use the above, behavior is undefined.</p>
<p>There are two main gotchas and one consideration: The <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/readdir" class="fancy-link">readdir</a></code></span> function returns “.” (current directory) and “..” (parent directory). If you are looking for sub-directories, you need to explicitly exclude these directories.</p>
<p>For many applications it’s reasonable to check the current directory first before recursively searching sub-directories. This can be achieved by storing the results in a linked list, or resetting the directory struct to restart from the beginning.</p>
<p>The following code attempts to list all files in a directory recursively. As an exercise, try to identify the bugs it introduces.</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>Did you find all 5 bugs?</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>One final note of caution: <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/readdir" class="fancy-link">readdir</a></code></span> is not thread-safe! For multi-threaded searches use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/readdir_r" class="fancy-link">readdir_r</a></code></span> which requires the caller to pass in the address of an existing dirent struct.</p>
<p>See the man page of readdir for more details.</p>
<h3 id="linking" class="title-text">Linking</h3>
<p>Links are what force us to model a filesystem as a tree rather than a graph. While modelling the filesystem as a tree would imply that every inode has a unique parent directory, links allow inodes to present themselves as files in multiple places, potentially with different names, thus leading to an inode having multiple parents directories.</p>
<p>The first kind of link is a hard link. A hard link is simply an entry in a directory assigning some name to an inode number that already has a different name and mapping in either the same directory or a different one. If we already have a file on a file system we can create another link to the same inode using the ‘ln’ command:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ln file1.txt blip.txt
</code></pre></div></div>
<p>However blip.txt <em>is</em> the same file; if I edit blip I’m editing the same file as ‘file1.txt!’ We can prove this by showing that both file names refer to the same inode:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls -i file1.txt blip.txt
134235 file1.txt
134235 blip.txt
</code></pre></div></div>
<p>The equivalent C call is <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/link" class="fancy-link">link</a></code></span></p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>For simplicity the above examples made hard links inside the same directory. Hard links can be created anywhere inside the same filesystem.</p>
<p>The second kind of link is a soft link - or a symbolic link or a symlink. A symbolic link is different because it does not deal with inode numbers directly. Instead a symbolic link is a regular file with a special bit set and stores a path to another file. Quite simply, without the special bit, it is nothing more than a text file with a file path inside. Note that when people generally talk about a link without specifying hard or soft, they are referring to a hard link.</p>
<p>To create a symbolic link in the shell use <span><code class="highlighter-rouge">ln -s</code></span>. To read the contents of the link as just a file use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/readlink" class="fancy-link">readlink</a></code></span>. These are both demonstrated below:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ln -s file1.txt file2.txt
$ ls -i file1.txt blip.txt
134235 file1.txt
134236 file2.txt
134235 blip.txt
$ cat file1.txt
file1!
$ cat file2.txt
file1!
$ cat blip.txt
file1!
$ echo edited file2 &gt;&gt; file2.txt # &gt;&gt; is bash syntax for append to file
$ cat file1.txt
file1!
edited file2
$ cat file2.txt
I'm file1!
edited file2
$ cat blip.txt
file1!
edited file2
$ readlink myfile.txt
file2.txt
</code></pre></div></div>
<p>Note that <span><code class="highlighter-rouge">file2.txt</code></span> and <span><code class="highlighter-rouge">file1.txt</code></span> have different inode numbers, unlike the hard link, <span><code class="highlighter-rouge">blip.txt</code></span>.</p>
<p>There is a C library call to create symlinks which is similar to link:</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>Some advantages of symbolic links are</p>
<ul>
  <li>
    <p>Can refer to files that don’t exist yet</p>
  </li>
  <li>
    <p>Unlike hard links, can refer to directories as well as regular files</p>
  </li>
  <li>
    <p>Can refer to files (and directories) that exist outside of the current file system</p>
  </li>
</ul>
<p>However, symlinks have a key disadvantage, they as slower than regular files and directories. When the links contents are read, they must be interpreted as a new path to the target file, resulting in an additional call to open and read since the real file must be opened and read. Another disadvantage is that POSIX will not let you hard link directories whereas softlinks are allowed. The <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/ln" class="fancy-link">ln</a></code></span> command will only allow root to do this and only if you provide the <span><code class="highlighter-rouge">-d</code></span> option. However even root may not be able to perform this because most filesystems prevent it!</p>
<p>The integrity of the file system assumes the directory structure (excluding softlinks which we will talk about later) is a non-cyclic tree that is reachable from the root directory. It becomes expensive to enforce or verify this constraint if directory linking is allowed. Breaking these assumptions can cause file integrity tools to not be able to repair the file system. Recursive searches potentially never terminate and directories can have more than one parent but “..” can only refer to a single parent. All in all, a bad idea.</p>
<p>When you remove a file (using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/rm" class="fancy-link">rm</a></code></span> or <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/unlink" class="fancy-link">unlink</a></code></span>) you are removing an inode reference from a directory. However the inode may still be referenced from other directories. In order to determine if the contents of the file are still required, each inode keeps a reference count that is updated whenever a new link is created or destroyed. This count only tracks hard links, symlinks are allowed to refer to a non-existant file and thus, do not matter.</p>
<p>An example use of hard-links is to efficiently create multiple archives of a file system at different points in time. Once the archive area has a copy of a particular file, then future archives can re-use these archive files rather than creating a duplicate file. Apple’s “Time Machine” software does this.</p>
<h3 id="pathing" class="title-text">Pathing</h3>
<p>Now that we have definitions talk about directories, we come across the concept of a path. A path is a sequence of directories that provide one with a “path” in the filesystem graph. However, there are some nuances. It is possible to have a path called <code class="highlighter-rouge">a/b/../c/./</code>. Since <span><code class="highlighter-rouge">..</code></span> and <span><code class="highlighter-rouge">.</code></span> are special entries in directories, this is a valid path that actually refers to <code class="highlighter-rouge">a/c</code>. Most filesystem functions will allow uncompressed paths to be passed in. The C library provides a function <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/realpath" class="fancy-link">realpath</a></code></span> to compress the path or get the realpath. To simplify by hand remember that <span><code class="highlighter-rouge">..</code></span> means ‘parent folder’ and that <span><code class="highlighter-rouge">.</code></span> means ‘current folder’. Below is an example that illustrates the simplification of the <code class="highlighter-rouge">a/b/../c/.</code> by using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/cd" class="fancy-link">cd</a></code></span> in a shell to navigate a filesystem.</p>
<ol>
  <li>
    <p><span><code class="highlighter-rouge">cd a</code></span> (in a)</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">cd b</code></span> (in a/b)</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">cd ..</code></span> (in a, because .. represents ‘parent folder’)</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">cd c</code></span> (in a/c)</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge">cd .</code></span> (in a/c, because . represents ‘current folder’)</p>
  </li>
</ol>
<p>Thus, this path can be simplified to <span><code class="highlighter-rouge">a/c</code></span>.</p>
<h3 id="metadata" class="title-text">Metadata</h3>
<p>How can we distinguish between a regular file and a directory? For that matter there’s many other attributes that files also might contain. You may know that on most UNIX systems, unlike windows systems, a file’s type is not determined by its extension. How does the system know what type the file is?</p>
<p>All of this information is stored within an inode. To access it, use the stat calls. For example, to find out when my ‘notes.txt’ file was last accessed.</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>There are actually three versions of <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span>;</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>For example, you can use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fstat" class="fancy-link">fstat</a></code></span> to find out the meta-information about a file if you already have an file descriptor associated with that file</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/lstat" class="fancy-link">lstat</a></code></span> is almost the same as <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span> but handles symbolic links differently. From the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span> man page:</p>
<blockquote>
  <p>lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information about the link itself, not the file that it refers to.</p>
</blockquote>
<p>The stat functions make use of <span><code class="highlighter-rouge">struct stat</code></span>. From the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span> man page:</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>The <span><code class="highlighter-rouge">st_mode</code></span> field can be used to distinguish between regular files and directories. To accomplish this, you will also need the macros, <span><code class="highlighter-rouge">S_ISDIR</code></span> and <span><code class="highlighter-rouge">S_ISREG</code></span>.</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="permissions-and-bits" class="title-text">Permissions and bits<a class="anchor title-text" href="#permissions-and-bits">#</a>
</h2></div>

























































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Permissions are a key part of the way UNIX systems provide security in a filesystem. You may have noticed that the <span><code class="highlighter-rouge">st_mode</code></span> field in <span><code class="highlighter-rouge">struct stat</code></span> contains more than just the file type. It also contains the mode, a description detailing what a user can and can’t do with a given file. There are usually three sets of permissions for any file. Permissions for the <em>user</em>, the <em>group</em> and <em>other</em>. For each of the three catagories we need to keep track of whether or not the user is allowed to read the file, write to the file, and execute the file. Since there are three categories and three permissions, permissions are usually represented as a 3-digit octal number. For each digit the least significant byte corresponds to read privilages, the middle one to write privilages and the final byte to execute privilages. They are always presented as <em>User</em>, <em>Group</em>, <em>Other</em> (<em>UGO</em>). Below are some common examples:</p>
<ol>
  <li>
    <p>755: <span><code class="highlighter-rouge">rwx r-x r-x</code></span></p>

    <p>user: <span><code class="highlighter-rouge">rwx</code></span>, group: <span><code class="highlighter-rouge">r-x</code></span>, others: <span><code class="highlighter-rouge">r-x</code></span></p>

    <p>User can read, write and execute. Group and others can only read and execute.</p>
  </li>
  <li>
    <p>644: <span><code class="highlighter-rouge">rw- r– r–</code></span></p>

    <p>user: <span><code class="highlighter-rouge">rw-</code></span>, group: <span><code class="highlighter-rouge">r–</code></span>, others: <span><code class="highlighter-rouge">r–</code></span></p>

    <p>User can read and write. Group and others can only read.</p>
  </li>
</ol>
<p>It is worth noting that the <span><code class="highlighter-rouge">rwx</code></span> bits for a directory have slightly different meaning. Write-access to a directory will allow you to create or delete new files or directories inside (you can think about this as just having write access to the dirent mappings). Read-access to a directory will allow you to list a directory’s contents (this is just read access to the dirent mapping). Execute will allow you to enter the directory and access it. Without the execute bit it is not possible to create or remove files or directories since you cannot access them. You can, however, list the contents of the directory.</p>
<p>There are several command line utilities for interacting with a file’s mode. <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mknod" class="fancy-link">mknod</a></code></span> changes the type of the file. <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/chmod" class="fancy-link">chmod</a></code></span> takes a number and a file and changes the permission bits. However, before we can dicuss chmod in detail, we must also understand the user id (<span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/uid" class="fancy-link">uid</a></code></span>) and group id (<span><code class="highlighter-rouge">gid</code></span>) as well.</p>
<h3 id="user-idgroup-id" class="title-text">User id/Group id</h3>
<p>Every user in a UNIX system has a user id. This is a unique number that can identify a user. Similarly, users can be added to collections called groups, and every group also has a uniquely identifying number. Groups have a variety of uses on UNIX systems. They can be assigned capabilities - a way of describing the level of control a user has over a system. For example, a group you may have run into is the <span><code class="highlighter-rouge">sudoers</code></span> group, a set of trusted users who are allowed to use the command <span><code class="highlighter-rouge">sudo</code></span> to temporarily gain higher privilages. (We’ll talk more about how <span><code class="highlighter-rouge">sudo</code></span> works in this chapter). Every file, upon creation, an owner, the creator of the file. This owner’s user id (<span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/uid" class="fancy-link">uid</a></code></span>) can be found inside the <span><code class="highlighter-rouge">st_mode</code></span> file of a <span><code class="highlighter-rouge">struct stat</code></span> with a call to <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span>. Similarly the group id (<span><code class="highlighter-rouge">gid</code></span>) is set as well.</p>
<p>Every process can determine it’s <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/uid" class="fancy-link">uid</a></code></span> and <span><code class="highlighter-rouge">gid</code></span> with <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/getuid" class="fancy-link">getuid</a></code></span> and <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/getgid" class="fancy-link">getgid</a></code></span>. When a processes tries to open a file with a specific mode, it’s <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/uid" class="fancy-link">uid</a></code></span> and <span><code class="highlighter-rouge">gid</code></span> are compared with the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/uid" class="fancy-link">uid</a></code></span> and <span><code class="highlighter-rouge">gid</code></span> of the file. If the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/uid" class="fancy-link">uid</a></code></span>s match, then the process’s request to open the file will be compared with the bits on the user field of the file’s permissions. Similarly, if the <span><code class="highlighter-rouge">gid</code></span>s match, then the process’s request will be compared with the group field of the permissions. Finally, if none of the ids match, then the other field will apply.</p>
<h3 id="readingchanging-file-permissions" class="title-text">Reading/Changing file permissions</h3>
<p>Before we discuss how to change permission bits, we should be able to read them. In C, the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span> family of library calls can be used. To read permission bits from the command line, use ‘ls -l’. Note that the permissions will outputed in the format ‘drwxrwxrwx’. The first character indicates the type of file type. Possible values for the first character:</p>
<ol>
  <li>
    <p>(-) regular file</p>
  </li>
  <li>
    <p>(d) directory</p>
  </li>
  <li>
    <p>(c) character device file</p>
  </li>
  <li>
    <p>(l) symbolic link</p>
  </li>
  <li>
    <p>(p) pipe</p>
  </li>
  <li>
    <p>(b) block device</p>
  </li>
  <li>
    <p>(s) socket</p>
  </li>
</ol>
<p>Alternatively, use the program <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span> which presents all the information that one could retrieve from the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stat" class="fancy-link">stat</a></code></span> library call.</p>
<p>To change the permission bits, there is a system call, <span><code class="highlighter-rouge">int chmod(const char *path, mode_t mode);</code></span>. In order to simplify our examples, we will be using the command line utility of the same name <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/chmod" class="fancy-link">chmod</a></code></span> (short of “change mode”). There are two common ways to use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/chmod" class="fancy-link">chmod</a></code></span> ; either with an octal value or with a symbolic string:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ chmod 644 file1
$ chmod 755 file2
$ chmod 700 file3
$ chmod ugo-w file4
$ chmod o-rx file4
</code></pre></div></div>
<p>The base-8 (‘octal’) digits describe the permissions for each role: The user who owns the file, the group and everyone else. The octal number is the sum of three values given to the three types of permission: read(4), write(2), execute(1)</p>
<p>Example: chmod 755 myfile</p>
<ol>
  <li>
    <p>r + w + x = digit * user has 4+2+1, full permission</p>
  </li>
  <li>
    <p>group has 4+0+1, read and execute permission</p>
  </li>
  <li>
    <p>all users have 4+0+1, read and execute permission</p>
  </li>
</ol>
<h3 id="understanding-the-umask" class="title-text">Understanding the ‘umask’</h3>
<p>The umask <em>subtracts</em> (reduces) permission bits from <span><code class="highlighter-rouge">777</code></span> and is used when new files and new directories are created by open, mkdir etc. By default the umask is set to <span><code class="highlighter-rouge">022</code></span> (octal), which means that group and other privileges will not include the writable bit . Each process (including the shell) has a current umask value. When forking, the child inherits the parent’s umask value.</p>
<p>For example, by setting the umask to <span><code class="highlighter-rouge">077</code></span> in the shell, ensures that future file and directory creation will only be accessible to the current user,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ umask 077
$ mkdir secretdir
</code></pre></div></div>
<p>As a code example, suppose a new file is created with <span><code class="highlighter-rouge">open()</code></span> and mode bits <span><code class="highlighter-rouge">666</code></span> (write and read bits for user,group and other):</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>If umask is octal <span><code class="highlighter-rouge">022</code></span>, then the permissions of the created file will be <span><code class="highlighter-rouge">0666</code></span> &amp; ~<span><code class="highlighter-rouge">022</code></span> ie.</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<h3 id="the-setuid-bit" class="title-text">The ‘setuid’ bit</h3>
<p>You may have noticed an additional bit that files with execute permission may have set. This bit is the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/setuid" class="fancy-link">setuid</a></code></span> bit. It indicated that when run, the program with set the uid of the user to that of the owner of the file. Similar, there is a <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/setgid" class="fancy-link">setgid</a></code></span> bit which sets the gid of the executor to the gid of the owner. The canonical example of a program with <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/setuid" class="fancy-link">setuid</a></code></span> set is <span><code class="highlighter-rouge">sudo</code></span>.</p>
<p><span><code class="highlighter-rouge">sudo</code></span> is usually a program that is owned by the root user - a user that has all capabilities. By using <span><code class="highlighter-rouge">sudo</code></span> an otherwise unprivilaged user can gain access to most parts of the system. This is useful for running programs that may require elevated privilages, such as using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/chown" class="fancy-link">chown</a></code></span> to change ownership of a file, or to use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/2/mount" class="fancy-link">mount</a></code></span> to mount or unmount filesystems (an action we will discuss later in this chapter). Here are some examples:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo mount /dev/sda2 /stuff/mydisk
$ sudo adduser fred
$ ls -l /usr/bin/sudo
-r-s--x--x  1 root  wheel  327920 Oct 24 09:04 /usr/bin/sudo
</code></pre></div></div>
<div class="pad"><div class="card">
<h4 id="effective-uidgid">Effective uid/gid</h4>

<p>When executing a process with the setuid bit, it is still possible to determine a user’s original uid with <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/getuid" class="fancy-link">getuid</a></code></span>. The real action of the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/setuid" class="fancy-link">setuid</a></code></span> bit is to set the effective userid (<span><code class="highlighter-rouge">euid</code></span>) which can be determined with <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/geteuid" class="fancy-link">geteuid</a></code></span>. The actions of <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/getuid" class="fancy-link">getuid</a></code></span> and <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/geteuid" class="fancy-link">geteuid</a></code></span> are described below.</p>

<ul>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/getuid" class="fancy-link">getuid</a></code></span> returns the real user id (zero if logged in as root)</p>
  </li>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/geteuid" class="fancy-link">geteuid</a></code></span> returns the effective userid (zero if acting as root, e.g. due to the setuid flag set on a program)</p>
  </li>
</ul>

<p>These functions can allow one to write a program that can only be run by a privilaged user by checking <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/geteuid" class="fancy-link">geteuid</a></code></span> or go a step further and ensure that the only user who can run the code is root by using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/getuid" class="fancy-link">getuid</a></code></span>.</p>

<h3 id="the-sticky-bit" class="title-text">The ‘sticky’ bit</h3>

<p>Sticky bits as we use them today do not serve the same purpose as their intial introduction. Sticky bits were a bit that could be set on an executable file that would allow a program’s text segment to remain in swap even after the end of the program’s execution. This made subsequent executions of the same program faster. Today, this behavior is no longer supported and the sticky bit only holds meaning when set on a directory,</p>

<p>When a directory’s sticky bit is set only the file’s owner, the directory’s owner, and the root user can rename or delete the file. This is useful when multiple users have write access to a common directory. A common use of the sticky bit is for the shared and writable <span><code class="highlighter-rouge">/tmp</code></span> directory.</p>

<p>To set the sticky bit, use <span><code class="highlighter-rouge">chmod +t</code></span>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aneesh$ mkdir sticky
aneesh$ chmod +t sticky 
aneesh$ ls -l
drwxr-xr-x  7 aneesh aneesh    4096 Nov  1 14:19 .
drwxr-xr-x 53 aneesh aneesh    4096 Nov  1 14:19 ..
drwxr-xr-t  2 aneesh aneesh    4096 Nov  1 14:19 sticky
aneesh$ su newuser
newuser$ rm -rf sticky
rm: cannot remove 'sticky': Permission denied
newuser$ exit
aneesh$ rm -rf sticky
aneesh$ ls -l
drwxr-xr-x  7 aneesh aneesh    4096 Nov  1 14:19 .
drwxr-xr-x 53 aneesh aneesh    4096 Nov  1 14:19 ..
</code></pre></div></div>

<p>Note that in the example above, the username is prepended to the prompt, and the command <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/su" class="fancy-link">su</a></code></span> is used to switch users.</p>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="virtual-filesystems-and-other-filesystems" class="title-text">Virtual filesystems and other filesystems<a class="anchor title-text" href="#virtual-filesystems-and-other-filesystems">#</a>
</h2></div>































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>POSIX systems, such as Linux and Mac OSX (which is based on BSD) include several virtual filesystems that are mounted (available) as part of the file-system. Files inside these virtual filesystems do not exist on the disk; they are generated dynamically by the kernel when a process requests a directory listing. Linux provides 3 main virtual filesystems</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev  - A list of physical and virtual devices (for example network card, cdrom, random number generator)
/proc - A list of resources used by each process and (by tradition) set of system information
/sys - An organized list of internal kernel entities
</code></pre></div></div>
<p>For example if I want a continuous stream of 0s, I can <span><code class="highlighter-rouge">cat /dev/zero</code></span>.</p>
<p>Another example is the file <span><code class="highlighter-rouge">/dev/null</code></span> - a great place to store bits that you never need to read! Bytes sent to <span><code class="highlighter-rouge">/dev/null/</code></span> are never stored - they are simply discarded. A common use of <span><code class="highlighter-rouge">/dev/null</code></span> is to discard standard output. For example,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls . &gt;/dev/null
</code></pre></div></div>
<h3 id="managing-files-and-filesystems" class="title-text">Managing files and filesystems</h3>
<p>Given the multitude of operations that are availible to you from the filesystem, let’s explore some tools and techniques that can be used to manage files and filesystems.</p>
<p>One example is creating a secure directory. Suppose you created your own directory in /tmp and then set the permissions so that only you can use the directory (see below). Is this secure?</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir /tmp/mystuff
$ chmod 700 /tmp/mystuff
</code></pre></div></div>
<p>There is a window of opportunity between when the directory is created and when it’s permissions are changed. This leads to several vulnerabilities that are based on a race condition.</p>
<p>Another user replaces <span><code class="highlighter-rouge">mystuff</code></span> with a hardlink to an existing file or directory owned by the second user, then they would be able to read and control the contents of the <span><code class="highlighter-rouge">mystuff</code></span> directory. Oh no - our secrets are no longer secret!</p>
<p>However in this specific example the <span><code class="highlighter-rouge">/tmp</code></span> directory has the sticky bit set, so other users may not delete the <span><code class="highlighter-rouge">mystuff</code></span> directory, and the simple attack scenario described above is impossible. This does not mean that creating the directory and then later making the directory private is secure! A better version is to atomically create the directory with the correct permissions from its inception -</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir -m 700 /tmp/mystuff
</code></pre></div></div>
<h3 id="obtaining-random-data" class="title-text">Obtaining random data</h3>
<p><span><code class="highlighter-rouge">/dev/random</code></span> is a file which contains number generator where the entropy is determined from environmental noise. Random will block/wait until enough entropy is collected from the environment.</p>
<p><span><code class="highlighter-rouge">/dev/urandom</code></span> is like random, but differs in the fact that it allows for repetition (lower entropy threshold), thus wont block.</p>
<h3 id="copying-files" class="title-text">Copying Files</h3>
<p>Use the versatile <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/dd" class="fancy-link">dd</a></code></span> command. For example, the following command copies 1 MB of data from the file <span><code class="highlighter-rouge">/dev/urandom</code></span> to the file <span><code class="highlighter-rouge">/dev/null</code></span>. The data is copied as 1024 blocks of blocksize 1024 bytes.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dd if=/dev/urandom of=/dev/null bs=1k count=1024
</code></pre></div></div>
<p>Both the input and output files in the example above are virtual - they don’t exist on a disk. This means the speed of the transfer is unaffected by hardware power.</p>
<p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/dd" class="fancy-link">dd</a></code></span> is also commonly used to make a copy of a disk or an entire filesystem to create images that can either be burned on to other disks or to distribute data to other users.</p>
<h3 id="updating-modification-time" class="title-text">Updating Modification Time</h3>
<p>The <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/touch" class="fancy-link">touch</a></code></span> executable creates file if it does not exist and also updates the file’s last modified time to be the current time. For example, we can make a new private file with the current time:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ umask 077       # all future new files will maskout all r,w,x bits for group and other access
$ touch file123   # create a file if it does not exist, and update its modified time
$ stat file123
  File: `file123'
  Size: 0           Blocks: 0          IO Block: 65536  regular empty file
Device: 21h/33d Inode: 226148      Links: 1
Access: (0600/-rw-------)  Uid: (395606/ angrave)   Gid: (61019/     ews)
Access: 2014-11-12 13:42:06.000000000 -0600
Modify: 2014-11-12 13:42:06.001787000 -0600
Change: 2014-11-12 13:42:06.001787000 -0600
</code></pre></div></div>
<p>An example use of touch is to force make to recompile a file that is unchanged after modifying the compiler options inside the makefile. Remeber that make is ‘lazy’ - it will compare the modified time of the source file with the corresponding output file to see if the file needs to be recompiled</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ touch myprogram.c   # force my source file to be recompiled
$ make
</code></pre></div></div>
<h3 id="managing-filesystems" class="title-text">Managing Filesystems</h3>
<p>To manage filesystems on your machine, use <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/2/mount" class="fancy-link">mount</a></code></span>. Using mount without any options generates a list (one filesystem per line) of mounted filesystems including networked, virtual and local (spinning disk / SSD-based) filesystems. Here is a typical output of mount</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mount
/dev/mapper/cs241--server_sys-root on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
/dev/sda1 on /boot type ext3 (rw)
/dev/mapper/cs241--server_sys-srv on /srv type ext4 (rw)
/dev/mapper/cs241--server_sys-tmp on /tmp type ext4 (rw)
/dev/mapper/cs241--server_sys-var on /var type ext4 (rw)rw,bind)
/srv/software/Mathematica-8.0 on /software/Mathematica-8.0 type none (rw,bind)
engr-ews-homes.engr.illinois.edu:/fs1-homes/angrave/linux on /home/angrave type nfs (rw,soft,intr,tcp,noacl,acregmin=30,vers=3,sec=sys,sloppy,addr=128.174.252.102)
</code></pre></div></div>
<p>Notice that each line includes the filesystem type source of the filesystem and mount point. To reduce this output we can pipe it into <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/grep" class="fancy-link">grep</a></code></span> and only see lines that match a regular expression.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;mount | grep proc  # only see lines that contain 'proc'
proc on /proc type proc (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
</code></pre></div></div>
<div class="pad"><div class="card">
<h4 id="filesystem-mounting">Filesystem Mounting</h4>

<p>Suppose you had downloaded a bootable linux disk image from the <a href="http://cosmos.cites.illinois.edu/pub/archlinux/iso/2015.04.01/archlinux-2015.04.01-dual.iso" class="fancy-link wiki-link">URL</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget $URL
</code></pre></div></div>

<p>Before putting the filesystem on a CD, we can mount the file as a filesystem and explore its contents. Note, mount requires root access, so let’s run it using sudo</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir arch
$ sudo mount -o loop archlinux-2015.04.01-dual.iso ./arch
$ cd arch
</code></pre></div></div>

<p>Before the mount command, the arch directory is new and obviously empty. After mounting, the contents of <span><code class="highlighter-rouge">arch/</code></span> will be drawn from the files and directories stored in the filesystem stored inside the <span><code class="highlighter-rouge">archlinux-2014.11.01-dual.iso</code></span> file. The <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/loop" class="fancy-link">loop</a></code></span> option is required because we want to mount a regular file not a block device such as a physical disk.</p>

<p>The loop option wraps the original file as a block device - in this example we will find out below that the file system is provided under <span><code class="highlighter-rouge">/dev/loop0</code></span> : We can check the filesystem type and mount options by running the mount command without any parameters. We will pipe the output into <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/1/grep" class="fancy-link">grep</a></code></span> so that we only see the relevant output line(s) that contain ‘arch’</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mount | grep arch
/home/demo/archlinux-2014.11.01-dual.iso on /home/demo/arch type iso9660 (rw,loop=/dev/loop0)
</code></pre></div></div>

<p>The iso9660 filesystem is a read-only filesystem originally designed for optical storage media (i.e. CDRoms). Attempting to change the contents of the filesystem will fail</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ touch arch/nocando
touch: cannot touch `/home/demo/arch/nocando': Read-only file system
</code></pre></div></div>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="memory-mapped-io" class="title-text">Memory Mapped IO<a class="anchor title-text" href="#memory-mapped-io">#</a>
</h2></div>



















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>While we traditionally think of reading and writing from a file as operation that happen by using the <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code></span> and <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code></span> calls, there is an alternative, mapping a file into memory using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span>. <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> can also be used for IPC, and you can see more about <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> as a system call that enables shared memory in the IPC chapter. In this chapter, we’ll briefly explore <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> as a filesystem operation.</p>
<p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> takes a file and maps its contents into memory. This allows a user to treat the entire file as a buffer in memory for easier semantics while programming, and to avoid having to read a file as discreete chunks explicitly.</p>
<p>Not all filesystems support using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> for IO, but amongst those that do, not all have the same behavior. Some will simply implement <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> as a wrapper around <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code></span> and <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code></span>. Others will add additional optimizations by taking advantage of the kernel’s page cache. Of course, such optimization can be used in the implementation of <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/read" class="fancy-link">read</a></code></span> and <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code></span> as well, so often using <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> does not impact performance.</p>
<p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> is used to perform some operations such as loading libraries and processes into memory. If many programs only need read-access to the same file (e.g. <span><code class="highlighter-rouge">/bin/bash</code></span>, the C library) then the same physical memory can be shared between multiple processes.</p>
<p>The process to map a file into memory is simple:</p>
<ol>
  <li>
    <p><span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code></span> requires a filedescriptor, so we need to <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code></span> the file first</p>
  </li>
  <li>
    <p>We seek to our desired size and write one byte to ensure that the file is sufficient length</p>
  </li>
  <li>
    <p>When finished call munmap to unmap the file from memory.</p>
  </li>
</ol>
<p>Here is a quick example.</p>
<div class="language-c highlighter-rouge">
<span class="o">&lt;</span>
</div>
<p>The careful reader may notice that our integers were written in least-significant-byte format (because that is the endianess of the CPU) and that we allocated a file that is one byte too many! The <span><code class="highlighter-rouge">PROT_READ | PROT_WRITE</code></span> options specify the virtual memory protection. The option <span><code class="highlighter-rouge">PROT_EXEC</code></span> (not used here) can be set to allow CPU execution of instructions in memory (e.g. this would be useful if you mapped an executable or library).</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="reliable-single-disk-filesystems" class="title-text">Reliable Single Disk Filesystems<a class="anchor title-text" href="#reliable-single-disk-filesystems">#</a>
</h2></div>













































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Most filesystems cache significant amounts of disk data in physical memory. Linux, in this respect, is particularly extreme: All unused memory is used as a giant disk cache. The disk cache can have significant impact on overall system performance because disk I/O is slow. This is especially true for random access requests on spinning disks where the disk read-write latency is dominated by the seek time required to move the read-write disk head to the correct position.</p>
<p>For efficiency, the kernel caches recently used disk blocks. For writing, we have to choose a trade-off between performance and reliability: Disk writes can also be cached (“Write-back cache”) where modified disk blocks are stored in memory until evicted. Alternatively a ‘write-through cache’ policy can be employed where disk writes are sent immediately to the disk. The latter is safer (as filesystem modifications are quickly stored to persistent media) but slower than a write-back cache; If writes are cached then they can be delayed and efficiently scheduled based on the physical position of each disk block. Note this is a simplified description because solid state drives (SSDs) can be used as a secondary write-back cache.</p>
<p>Both solid state disks (SSD) and spinning disks have improved performance when reading or writing sequential data. Thus operating system can often use a read-ahead strategy to amortize the read-request costs (e.g. time cost for a spinning disk) and request several contiguous disk blocks per request. By issuing an I/O request for the next disk block before the user application requires the next disk block, the apparent disk I/O latency can be reduced.</p>
<p>If your data is important and needs to be force written to disk, call <span><code class="highlighter-rouge"><a href="https://linux.die.net/man/3/sync" class="fancy-link">sync</a></code></span> to request that a filesystem changes be written (flushed) to disk. However, not all operating systems honor this request and even if the data is evicted from the kernel buffers the disk firmware use an internal on-disk cache or may not yet have finished changing the physical media. Note you can also request that all changes associated with a particular file descriptor are flushed to disk using <span><code class="highlighter-rouge">fsync(int fd)</code></span></p>
<p>If your operating system fails in the middle of an operation, most modern file systems do something called <strong>journalling</strong> that work around this. What the file system does is before it completes a potentially expensive operation, is that it writes what it is going to do down in a journal. In the case of a crash or failure, one can step through the journal and see which files are corrupt and fix them. This is a way to salvage hard disks in cases there is critical data and there is no apparent backup.</p>
<p>Even though it is unlikely for your computer, programming for datacenters means that disks fail every few seconds. Disk failures are measured using “Mean-Time-Failure”. For large arrays, the mean failure time can be surprisingly short. For example if the MTTF(single disk) = 30,000 hours, then the MTTF(1000 disks)= 30000/1000=30 hours or about a day and a half!</p>
<h3 id="raid" class="title-text">RAID</h3>
<p>One way to protect against this is to store the data twice! This is the main principle of a “RAID-1” disk array. RAID is short for redundant array of inexpensive disks. By duplicating the writes to a disk with writes to another backup disk, there are exactly two copies of the data. If one disk fails, the other disk serves as the only copy until it can be re-cloned. Reading data is faster since data can be requested from either disk, but writes are potentially twice as slow because now two write commands need to be issued for every disk block write. Compared to using a single disk, the cost of storage per byte has doubled.</p>
<p>Another common RAID scheme is RAID-0, meaning that a file could be split up amoung two disks, but if any one of the disks fail then the files are irrecoverable. This has the benefit of halving write times because one part of the file could be writing to hard disk one and another part to hard disk two.</p>
<p>It is also common to combine these systems. If you have a lot of hard disks, consider RAID-10. This is where you have two systems of RAID-1, but the systems are hooked up in RAID-0 to each other. This means you would get roughly the same speed from the slowdowns but now any one disk can fail and you can recover that disk. If two disks from opposing raid partitions fail there is a chance that recover can happen though we don’t could on it most of the time.</p>
<h3 id="higher-level-raids" class="title-text">Higher Level Raids</h3>
<p>RAID-3 uses parity codes instead of mirroring the data. For each N-bits written we will write one extra bit, the ‘Parity bit’ that ensures the total number of 1s written is even. The parity bit is written to an additional disk. If any one disk (including the parity disk) is lost, then its contents can still be computed using the contents of the other disks.</p>
<p><img src="https://raw.githubusercontent.com/illinois-cs241/wikibook-project/master/filesystems/images/raid.gif" alt=""></p>
<p>One disadvantage of RAID-3 is that whenever a disk block is written, the parity block will always be written too. This means that there is effectively a bottleneck in a separate disk. In practice, this is more likely to cause a failure because one disk is being used 100% of the time and once that disk fails then the other disks are more prone to failure.</p>
<p>A single disk failure will not result in data loss (because there is sufficient data to rebuild the array from the remaining disks). Data-loss will occur when a two disks are unusable because there is no longer sufficient data to rebuild the array. We can calculate the probability of a two disk failure based on the repair time which includes not just the time to insert a new disk but the time required to rebuild the entire contents of the array.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MTTF = mean time to failure
MTTR = mean time to repair
N = number of original disks

p = MTTR / (MTTF-one-disk / (N-1))
</code></pre></div></div>
<p>Using typical numbers (MTTR=1day, MTTF=1000days, N-1 = 9, p=0.009)</p>
<p>There is a 1% chance that another drive will fail during the rebuild process (at that point you had better hope you still have an accessible backup of your original data. In practice the probability of a second failure during the repair process is likely higher because rebuilding the array is I/O-intensive (and on top of normal I/O request activity). This higher I/O load will also stress the disk array</p>
<p>RAID-5 is similar to RAID-3 except that the check block (parity information) is assigned to different disks for different blocks. The check-block is ‘rotated’ through the disk array. RAID-5 provides better read and write performance than RAID-3 because there is no longer the bottleneck of the single parity disk. The one drawback is that you need more disks to have this setup and there are more complicated algorithms need to be used</p>
<p><img src="https://raw.githubusercontent.com/illinois-cs241/wikibook-project/master/filesystems/images/raid_5.png"></p>
<p>Failure is the common case. Google reports 2-10% of disks fail per year Now multiply that by 60,000+ disks in a single warehouse… Must survive failure of not just a disk, but a rack of servers or a whole data center</p>
<p>Solutions Simple redundancy (2 or 3 copies of each file) e.g., Google GFS (2001) More efficient redundancy (analogous to RAID 3++) e.g., <a href="http://goo.gl/LwFIy" class="fancy-link wiki-link">Google Colossus filesystem</a> (~2010): customizable replication including Reed-Solomon codes with 1.5x redundancy</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="simple-filesystem-model" class="title-text">Simple Filesystem Model<a class="anchor title-text" href="#simple-filesystem-model">#</a>
</h2></div>































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Okay so software developers need to implement filesystems all the time. Don’t believe me? Take a look at Hadoop, GlusterFS, Qumulo, etc. Filesystems are hot areas of research now because people have realized that the software models that we devised don’t take full advantage of our current hardware. As such, you may be doing a lot of filesystem writing. Here we will go over one of our fake filesystems that we talke about in class and “walk through” some of the code and</p>
<p>So what does our hypothetical filesystem look like? We will base it off of the Minixfs, the first filesystem that Linux ran on. We’ll do this and try to make the filesystem as easy as possible. Laid out sequentually, we have our superblock. The superblock stores important metadata about the filesystem. After the superblock, we’ll keep a map of which inodes are being used. The n’th bit is set if the n’th inode – from the inode root – is set with the exact same convention for data blocks. Let’s consider a single file that spans all of its direct blocks and some indirect blocks with some omitted. In our pretend filesystem, for simplicity let’s assume that we are not going to delete any directory entries and every file is compact. This means that each file uses up any partial used data block before allocating a new data block. A sample image is below.</p>
<p><img src="https://raw.githubusercontent.com/illinois-cs241/wikibook-project/master/filesystems/images/sample_file.png" alt="image"></p>
<p>We will assume that a data block is 4 KB.</p>
<h3 id="performing-reads" class="title-text">Performing Reads</h3>
<p>Performing reads tend to be pretty easy in our filesystem because our files our compact Let’s say that we want to read the entirety of this particular file. What we’d start by doing is go to the inode’s direct struct and find the first direct inode number. In our case it is #7. Then we find the 7th data block from the <em>start</em> of all data blocks. Then we read all of those bytes. We do the same thing for all of the direct nodes. What do we do after? We go to the indirect block and read the indirect block. We know that every 4 bytes of the indirect block are either a sentinel node (-1) or the number of <em>another</em> data block. In our particular example, the first four bytes evaluate to the integer 5, meaning that our data continues on the 5th datablock from the beginning. We do the same for data block #4 and we stop after because we exceed the size of the inode</p>
<p>Now, let’s think about the edge cases. How would you start the read starting at an arbitrary offset of (n) bytes given that block sizes are (4 KBs). How many indirect blocks should there be if the filesystem is correct (hint: <em>think about using the size of the inode</em>)</p>
<h3 id="performing-writes" class="title-text">Performing Writes</h3>
<p>Performing writes fall into two categories, writes to files and writes to directories. First we’ll focus on files and assume that we are writing a byte to the (6)th KB of our file. To perform a write on a file at a particular offset, first you must go to the data block would start at that offset. For this particular example we would have to go to the 2nd or indexed number 1 inode to perform our write. We would once again fetch this number from the inode, go to the root of the data blocks, go to the (5)th data block and perform our write at the (2)KB offset from this block because we skipped the first four kilobytes of the file in block 7. We perform our write and go on our merry way</p>
<p>Some questions for you. How would you consider performing a write that would go across data block boundaries? How would you consider performing a write whose write after adding the offset would extend the length of the file? How would you consider performing a write where the offset is greater than the length of the original file?</p>
<p>Performing a write to a directory meaning that an inode needs to be added to a directory. If we pretend that the example above is a directory. We know that we will be adding at most one directory entry at a time. Meaning that we have to have enough space for one directory entry in our datablocks. Luckily the last data block that we have has enough free space. This means we just need to find the number of the last data block as we did above, go to where the data ends, and write one directory entry. Don’t forget to update the size of the directory so that the next creation doesn’t overwrite your file!</p>
<p>Some more questions. How would you consider performing a write when the last data block is already full? How about when all the direct blocks have just been filled up and the inode doesn’t have an indirect block? What about when the first indirect entry (#4) is full? These are all edge cases you have to think about for a filesystem that really get you</p>
<h3 id="adding-deletes" class="title-text">Adding Deletes</h3>
<p>Although this isn’t part of the lab originally. If you were to ask what happens when a file gets deleted, it’s actually pretty simple. If the inode is a file, then remove the directory entry in the parent directory by marking it as invalid (maybe making it point to inode -1) and skip it in your reads. You need to make sure to decrease the hard link count of the inode and if the count reaches zero, free the inode in the inode map and free all associated data blocks so they are reclaimed by the filesystem.</p>
<p>If the inode is a directory, first you have to recursively remove every directory entry inside After, you have to mark the directory’s inode as free and set the associated datablocks to free as well. Why don’t we have to check hardlink counts for directories? Because you can’t hard link directories! Meaning, we can just easily delete it.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="topics" class="title-text">Topics<a class="anchor title-text" href="#topics">#</a>
</h2></div>



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ul>
  <li>
    <p>Superblock</p>
  </li>
  <li>
    <p>Data Block</p>
  </li>
  <li>
    <p>Inode</p>
  </li>
  <li>
    <p>Relative Path</p>
  </li>
  <li>
    <p>File Metadata</p>
  </li>
  <li>
    <p>Hard and Soft Links</p>
  </li>
  <li>
    <p>Permission Bits</p>
  </li>
  <li>
    <p>Mode bits</p>
  </li>
  <li>
    <p>Working with Directories</p>
  </li>
  <li>
    <p>Virtual File System</p>
  </li>
  <li>
    <p>Reliable File Systems</p>
  </li>
  <li>
    <p>RAID</p>
  </li>
</ul></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="questions" class="title-text">Questions<a class="anchor title-text" href="#questions">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ul>
  <li>
    <p>How big can files be on a file system with 15 Direct blocks, 2 double, 3 triple indirect, 4kb blocks and 4byte entries? (Assume enough infinite blocks)</p>
  </li>
  <li>
    <p>What is a superblock? Inode? Datablock?</p>
  </li>
  <li>
    <p>How do I simplify <span><code class="highlighter-rouge">/./proc/../dev/./random</code></span>/</p>
  </li>
  <li>
    <p>In ext2, what is stored in an inode, and what is stored in a directory entry?</p>
  </li>
  <li>
    <p>What are /sys, /proc, /dev/random, and /dev/urandom?</p>
  </li>
  <li>
    <p>What are permission bits?</p>
  </li>
  <li>
    <p>How do you use chmod to set user/group/owner read/write/execute permissions?</p>
  </li>
  <li>
    <p>What does the “dd” command do?</p>
  </li>
  <li>
    <p>What is the difference between a hard link and a symbolic link? Does the file need to exist?</p>
  </li>
  <li>
    <p>“ls -l” shows the size of each file in a directory. Is the size stored in the directory or in the file’s inode?</p>
  </li>
</ul></div></div></div>
</div></div>
</div>
          
          <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook_project/Filesystems.md";
  </script>
  <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Again bust cache on the main.js file -->
<script src="/js/main.js?v='2018-11-28 20:00:31 -0600'"></script>

<script>
<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
